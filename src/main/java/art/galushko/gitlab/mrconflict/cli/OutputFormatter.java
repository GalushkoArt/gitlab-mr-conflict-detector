package art.galushko.gitlab.mrconflict.cli;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import art.galushko.gitlab.mrconflict.model.ConflictInfo;
import art.galushko.gitlab.mrconflict.model.MergeResult;

import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Formats conflict detection results in various output formats.
 */
public class OutputFormatter {
    private final String format;
    private final ObjectMapper jsonMapper;
    private final ObjectMapper yamlMapper;
    
    public OutputFormatter(String format) {
        this.format = format != null ? format.toUpperCase() : "TEXT";
        
        this.jsonMapper = new ObjectMapper();
        this.jsonMapper.enable(SerializationFeature.INDENT_OUTPUT);
        
        this.yamlMapper = new ObjectMapper(new YAMLFactory());
    }
    
    /**
     * Formats the merge results according to the configured format.
     *
     * @param results list of merge results to format
     * @return formatted output string
     */
    public String format(List<MergeResult> results) {
        return switch (format) {
            case "JSON" -> formatAsJson(results);
            case "YAML" -> formatAsYaml(results);
            default -> formatAsText(results);
        };
    }
    
    private String formatAsText(List<MergeResult> results) {
        StringBuilder output = new StringBuilder();
        
        output.append("GitLab Merge Request Conflict Detection Report\n");
        output.append("=".repeat(50)).append("\n\n");
        
        boolean hasAnyConflicts = results.stream().anyMatch(MergeResult::hasConflicts);
        
        // Summary
        output.append("Summary:\n");
        output.append("  Total target branches checked: ").append(results.size()).append("\n");
        output.append("  Branches with conflicts: ")
              .append(results.stream().mapToInt(r -> r.hasConflicts() ? 1 : 0).sum()).append("\n");
        output.append("  Overall status: ").append(hasAnyConflicts ? "CONFLICTS DETECTED" : "CLEAN").append("\n\n");
        
        // Detailed results
        for (MergeResult result : results) {
            output.append("Target Branch: ").append(result.getTargetBranch()).append("\n");
            output.append("-".repeat(30)).append("\n");
            output.append("  Source Branch: ").append(result.getSourceBranch()).append("\n");
            output.append("  Source Commit: ").append(result.getSourceCommit()).append("\n");
            output.append("  Target Commit: ").append(result.getTargetCommit()).append("\n");
            output.append("  Status: ").append(result.getStatus()).append("\n");
            
            if (result.getMessage() != null) {
                output.append("  Message: ").append(result.getMessage()).append("\n");
            }
            
            if (result.hasConflicts()) {
                output.append("  Conflicts (").append(result.getConflictCount()).append(" files):\n");
                
                for (ConflictInfo conflict : result.getConflicts()) {
                    output.append("    - ").append(conflict.getFilePath())
                          .append(" (").append(conflict.getType().name().toLowerCase()).append(")\n");
                    
                    if (!conflict.getSections().isEmpty()) {
                        output.append("      Conflict sections: ").append(conflict.getSections().size()).append("\n");
                    }
                }
            } else {
                output.append("  No conflicts detected\n");
            }
            
            output.append("  Timestamp: ")
                  .append(result.getTimestamp().atZone(java.time.ZoneId.systemDefault())
                         .format(DateTimeFormatter.ISO_LOCAL_DATE_TIME))
                  .append("\n\n");
        }
        
        // Footer
        output.append("Generated by GitLab MR Conflict Detector v1.0.0\n");
        
        return output.toString();
    }
    
    private String formatAsJson(List<MergeResult> results) {
        try {
            ConflictReport report = new ConflictReport(results);
            return jsonMapper.writeValueAsString(report);
        } catch (Exception e) {
            return "Error formatting JSON output: " + e.getMessage();
        }
    }
    
    private String formatAsYaml(List<MergeResult> results) {
        try {
            ConflictReport report = new ConflictReport(results);
            return yamlMapper.writeValueAsString(report);
        } catch (Exception e) {
            return "Error formatting YAML output: " + e.getMessage();
        }
    }
    
    /**
     * Wrapper class for structured output formats.
     */
    public static class ConflictReport {
        public final String version = "1.0.0";
        public final String timestamp = java.time.Instant.now().toString();
        public final Summary summary;
        public final List<MergeResult> results;
        
        public ConflictReport(List<MergeResult> results) {
            this.results = results;
            this.summary = new Summary(results);
        }
        
        public static class Summary {
            public final int totalTargetBranches;
            public final int branchesWithConflicts;
            public final int totalConflicts;
            public final String overallStatus;
            
            public Summary(List<MergeResult> results) {
                this.totalTargetBranches = results.size();
                this.branchesWithConflicts = (int) results.stream().filter(MergeResult::hasConflicts).count();
                this.totalConflicts = results.stream().mapToInt(MergeResult::getConflictCount).sum();
                this.overallStatus = branchesWithConflicts > 0 ? "CONFLICTS_DETECTED" : "CLEAN";
            }
        }
    }
}

